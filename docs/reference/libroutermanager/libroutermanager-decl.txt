<FUNCTION>
<NAME>ssdp_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>ssdp_get_routers</NAME>
<RETURNS>GList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>fax_printer_init</NAME>
<RETURNS>gboolean  </RETURNS>
GError **error
</FUNCTION>
<STRUCT>
<NAME>filter_rule</NAME>
struct filter_rule {
	gint type;
	gint sub_type;
	gchar *entry;
};
</STRUCT>
<STRUCT>
<NAME>filter</NAME>
struct filter {
	gchar *name;
	gchar *file;
	gboolean compare_or;
	GSList *rules;
};
</STRUCT>
<FUNCTION>
<NAME>filter_rule_match</NAME>
<RETURNS>gboolean  </RETURNS>
struct filter *filter, struct call *call
</FUNCTION>
<FUNCTION>
<NAME>filter_rule_add</NAME>
<RETURNS>void  </RETURNS>
struct filter *filter, gint type, gint sub_type, gchar *entry
</FUNCTION>
<FUNCTION>
<NAME>filter_new</NAME>
<RETURNS>struct filter  *</RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>filter_free</NAME>
<RETURNS>void  </RETURNS>
gpointer data
</FUNCTION>
<FUNCTION>
<NAME>filter_get_list</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>filter_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>filter_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>filter_add</NAME>
<RETURNS>void  </RETURNS>
struct filter *filter
</FUNCTION>
<FUNCTION>
<NAME>filter_remove</NAME>
<RETURNS>void  </RETURNS>
struct filter *filter
</FUNCTION>
<FUNCTION>
<NAME>filter_save</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<USER_FUNCTION>
<NAME>csv_parse_line_func</NAME>
<RETURNS>gpointer </RETURNS>
gpointer ptr, gchar **split
</USER_FUNCTION>
<FUNCTION>
<NAME>csv_parse_data</NAME>
<RETURNS>gpointer  </RETURNS>
const gchar *data, const gchar *header, csv_parse_line_func csv_parse_line, gpointer ptr
</FUNCTION>
<FUNCTION>
<NAME>csv_save_journal_as</NAME>
<RETURNS>gboolean  </RETURNS>
GSList *journal, gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>csv_save_journal</NAME>
<RETURNS>gboolean  </RETURNS>
GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>csv_load_journal</NAME>
<RETURNS>GSList  *</RETURNS>
GSList *journal
</FUNCTION>
<STRUCT>
<NAME>RmAuthData</NAME>
typedef struct auth_data {
	SoupMessage *msg;
	SoupAuth *auth;
	SoupSession *session;
	gboolean retry;
	gchar *username;
	gchar *password;
} RmAuthData;
</STRUCT>
<VARIABLE>
<NAME>rm_soup_session</NAME>
extern SoupSession *rm_soup_session;
</VARIABLE>
<FUNCTION>
<NAME>rm_network_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_network_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_network_authenticate</NAME>
<RETURNS>void  </RETURNS>
gboolean auth, RmAuthData *auth_data
</FUNCTION>
<MACRO>
<NAME>OS_OPEN</NAME>
#define OS_OPEN "start"
</MACRO>
<MACRO>
<NAME>APP_USER_DIR</NAME>
#define APP_USER_DIR APP_NAME
</MACRO>
<MACRO>
<NAME>gtk_label_new</NAME>
#define gtk_label_new(text) gtk_accel_label_new(text)
</MACRO>
<FUNCTION>
<NAME>rm_os_execute</NAME>
<RETURNS>void  </RETURNS>
const gchar *uri
</FUNCTION>
<STRUCT>
<NAME>device_phone</NAME>
struct device_phone {
	gchar *name;
	struct connection *(*dial)(const gchar *target, gboolean anonymous);
	gint (*pickup)(struct connection *connection);
	void (*hangup)(struct connection *connection);
	void (*hold)(struct connection *connection, gboolean hold);
	void (*send_dtmf_code)(struct connection *connection, guchar code);

	gboolean (*number_is_handled)(gchar *number);

	void (*mute)(struct connection *connection, gboolean mute);
	/*void (*record)(gpointer connection, guchar hold, const gchar *dir);*/
};
</STRUCT>
<FUNCTION>
<NAME>rm_phone_register</NAME>
<RETURNS>void  </RETURNS>
struct device_phone *phone
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_get_plugins</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_mute</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection, gboolean mute
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_hold</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection, gboolean hold
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_dtmf</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection, guchar code
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_hangup</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_pickup</NAME>
<RETURNS>gint  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>rm_phone_dial</NAME>
<RETURNS>struct connection  *</RETURNS>
const gchar *target, gboolean anonymous
</FUNCTION>
<ENUM>
<NAME>AppCallbackId</NAME>
typedef enum {
	ACB_JOURNAL_LOADED,
	ACB_CONNECTION_NOTIFY,
	ACB_CONTACT_PROCESS,
	ACB_FAX_PROCESS,
	ACB_CONNECTION_ESTABLISHED,
	ACB_CONNECTION_TERMINATED,
	ACB_CONNECTION_STATUS,
	ACB_MESSAGE,
	ACB_CONTACTS_CHANGED,
	ACB_AUTHENTICATE,
	ACB_MAX
} AppCallbackId;
</ENUM>
<MACRO>
<NAME>APP_OBJECT_TYPE</NAME>
#define APP_OBJECT_TYPE (app_object_get_type())
</MACRO>
<MACRO>
<NAME>APP_OBJECT</NAME>
#define APP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj), GEANY_OBJECT_TYPE, AppObject))
</MACRO>
<MACRO>
<NAME>APP_OBJECT_CLASS</NAME>
#define APP_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass), APP_OBJECT_TYPE, AppObjectClass))
</MACRO>
<MACRO>
<NAME>IS_APP_OBJECT</NAME>
#define IS_APP_OBJECT(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj), APP_OBJECT_TYPE))
</MACRO>
<MACRO>
<NAME>IS_APP_OBJECT_CLASS</NAME>
#define IS_APP_OBJECT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass), APP_OBJECT_TYPE))
</MACRO>
<STRUCT>
<NAME>AppObject</NAME>
struct _AppObject {
	GObject parent;
};
</STRUCT>
<STRUCT>
<NAME>AppObjectClass</NAME>
struct _AppObjectClass {
	GObjectClass parent_class;
	void (*journal_loaded)(GSList *journal);
	void (*connection_notify)(struct connection *connection);
	void (*contact_process)(struct contact *contact);
	void (*fax_process)(const gchar *filename);
	void (*connection_established)(struct capi_connection *connection);
	void (*connection_terminated)(struct capi_connection *connection);
	void (*connection_status)(gint status, struct capi_connection *connection);
	void (*message)(gchar *title, gchar *message);
	void (*contacts_changed)(void);
	void (*authenticate)(struct auth_data *auth_data);
};
</STRUCT>
<FUNCTION>
<NAME>app_object_new</NAME>
<RETURNS>GObject  *</RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>app_object</NAME>
extern GObject *app_object;
</VARIABLE>
<MACRO>
<NAME>EMPTY_STRING</NAME>
#define EMPTY_STRING(x) (!(x) || !strlen(x))
</MACRO>
<FUNCTION>
<NAME>g_strcasestr</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *haystack, const gchar *needle
</FUNCTION>
<FUNCTION>
<NAME>g_convert_utf8</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *text, gssize len
</FUNCTION>
<FUNCTION>
<NAME>strip_html</NAME>
<RETURNS>gchar  *</RETURNS>
gchar *text
</FUNCTION>
<FUNCTION>
<NAME>rm_strv_contains</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar * const *strv, const gchar *str
</FUNCTION>
<STRUCT>
<NAME>RmProfile</NAME>
typedef struct profile {
	/*< private >*/
	gchar *name;
	struct router_info *router_info;

	GSettings *settings;

	GSList *action_list;
} RmProfile;
</STRUCT>
<FUNCTION>
<NAME>rm_profile_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_get_list</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_add</NAME>
<RETURNS>RmProfile  *</RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_remove</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_get_active</NAME>
<RETURNS>RmProfile  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_set_active</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_detect_active</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_get_name</NAME>
<RETURNS>const gchar  *</RETURNS>
RmProfile *profile
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_set_host</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile, const gchar *host
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_set_login_user</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile, const gchar *user
</FUNCTION>
<FUNCTION>
<NAME>rm_profile_set_login_password</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile, const gchar *password
</FUNCTION>
<ENUM>
<NAME>RmConnectionType</NAME>
typedef enum {
	RM_CONNECTION_TYPE_INCOMING   = 0x01,
	RM_CONNECTION_TYPE_OUTGOING   = 0x02,
	RM_CONNECTION_TYPE_CONNECT    = 0x04,
	RM_CONNECTION_TYPE_DISCONNECT = 0x08,
	RM_CONNECTION_TYPE_MISSED     = (RM_CONNECTION_TYPE_INCOMING | RM_CONNECTION_TYPE_DISCONNECT),
	RM_CONNECTION_TYPE_SOFTPHONE  = 0x80,
} RmConnectionType;
</ENUM>
<STRUCT>
<NAME>RmConnection</NAME>
typedef struct connection {
	/* Unique ID */
	guint id;
	/* Type */
	guchar type;
	/* Local number */
	gchar *local_number;
	/* Remote number */
	gchar *remote_number;
	/* Notification widget */
	void *notification;
	/* Private data */
	void *priv;
	/* Connection time */
	GTimer *duration_timer;
} RmConnection;
</STRUCT>
<FUNCTION>
<NAME>rm_connection_add</NAME>
<RETURNS>RmConnection  *</RETURNS>
gint id, RmConnectionType type, const gchar *local_number, const gchar *remote_number
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_find_by_id</NAME>
<RETURNS>RmConnection  *</RETURNS>
gint id
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_find_by_remote_number</NAME>
<RETURNS>RmConnection  *</RETURNS>
const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_set_type</NAME>
<RETURNS>void  </RETURNS>
RmConnection *connection, RmConnectionType type
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_remove</NAME>
<RETURNS>void  </RETURNS>
RmConnection *connection
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_init_duration_timer</NAME>
<RETURNS>void  </RETURNS>
RmConnection *connection
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_shutdown_duration_timer</NAME>
<RETURNS>void  </RETURNS>
RmConnection *connection
</FUNCTION>
<FUNCTION>
<NAME>rm_connection_get_duration_time</NAME>
<RETURNS>gchar  *</RETURNS>
RmConnection *connection
</FUNCTION>
<STRUCT>
<NAME>ftp</NAME>
struct ftp {
	gchar *server;
	gint code;
	gchar *response;
	GIOChannel *control;
	GIOChannel *data;
	GTimer *timer;
};
</STRUCT>
<FUNCTION>
<NAME>ftp_read_response</NAME>
<RETURNS>gchar  *</RETURNS>
GIOChannel *channel, gsize *len
</FUNCTION>
<FUNCTION>
<NAME>ftp_send_command</NAME>
<RETURNS>gboolean  </RETURNS>
struct ftp *client, gchar *command
</FUNCTION>
<FUNCTION>
<NAME>ftp_login</NAME>
<RETURNS>gboolean  </RETURNS>
struct ftp *client, const gchar *user, const gchar *password
</FUNCTION>
<FUNCTION>
<NAME>ftp_passive</NAME>
<RETURNS>gboolean  </RETURNS>
struct ftp *client
</FUNCTION>
<FUNCTION>
<NAME>ftp_list_dir</NAME>
<RETURNS>gchar  *</RETURNS>
struct ftp *client, const gchar *dir
</FUNCTION>
<FUNCTION>
<NAME>ftp_get_file</NAME>
<RETURNS>gchar  *</RETURNS>
struct ftp *client, const gchar *file, gsize *len
</FUNCTION>
<FUNCTION>
<NAME>ftp_put_file</NAME>
<RETURNS>gboolean  </RETURNS>
struct ftp *client, const gchar *file, const gchar *path, gchar *data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>ftp_init</NAME>
<RETURNS>struct ftp  *</RETURNS>
const gchar *server
</FUNCTION>
<FUNCTION>
<NAME>ftp_delete_file</NAME>
<RETURNS>gboolean  </RETURNS>
struct ftp *client, const gchar *file
</FUNCTION>
<FUNCTION>
<NAME>ftp_shutdown</NAME>
<RETURNS>gboolean  </RETURNS>
struct ftp *client
</FUNCTION>
<MACRO>
<NAME>RM_ACTION_INCOMING_RING</NAME>
#define RM_ACTION_INCOMING_RING   0x01
</MACRO>
<MACRO>
<NAME>RM_ACTION_INCOMING_BEGIN</NAME>
#define RM_ACTION_INCOMING_BEGIN  0x02
</MACRO>
<MACRO>
<NAME>RM_ACTION_INCOMING_END</NAME>
#define RM_ACTION_INCOMING_END    0x04
</MACRO>
<MACRO>
<NAME>RM_ACTION_INCOMING_MISSED</NAME>
#define RM_ACTION_INCOMING_MISSED 0x08
</MACRO>
<MACRO>
<NAME>RM_ACTION_OUTGOING_DIAL</NAME>
#define RM_ACTION_OUTGOING_DIAL   0x10
</MACRO>
<MACRO>
<NAME>RM_ACTION_OUTGOING_BEGIN</NAME>
#define RM_ACTION_OUTGOING_BEGIN  0x20
</MACRO>
<MACRO>
<NAME>RM_ACTION_OUTGOING_END</NAME>
#define RM_ACTION_OUTGOING_END    0x40
</MACRO>
<STRUCT>
<NAME>RmAction</NAME>
typedef struct rm_action {
	/*< private >*/
	/** name */
	gchar *name;
	/** description */
	gchar *description;
	/** execution line */
	gchar *exec;
	/** flags - contains RM_ACTION_XXXX_YYYY values */
	guchar flags;
	/** list of numbers used within this action */
	gchar **numbers;

	/** settings storage of this action */
	GSettings *settings;
} RmAction;
</STRUCT>
<FUNCTION>
<NAME>rm_action_init</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile
</FUNCTION>
<FUNCTION>
<NAME>rm_action_shutdown</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile
</FUNCTION>
<FUNCTION>
<NAME>rm_action_get_list</NAME>
<RETURNS>GSList  *</RETURNS>
RmProfile *profile
</FUNCTION>
<FUNCTION>
<NAME>rm_action_add</NAME>
<RETURNS>RmAction  *</RETURNS>
RmProfile *profile, const gchar *action_name
</FUNCTION>
<FUNCTION>
<NAME>rm_action_remove</NAME>
<RETURNS>void  </RETURNS>
RmProfile *profile, RmAction *action
</FUNCTION>
<FUNCTION>
<NAME>rm_action_set_name</NAME>
<RETURNS>void  </RETURNS>
RmAction *action, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>rm_action_get_name</NAME>
<RETURNS>gchar  *</RETURNS>
RmAction *action
</FUNCTION>
<FUNCTION>
<NAME>rm_action_set_description</NAME>
<RETURNS>void  </RETURNS>
RmAction *action, const gchar *description
</FUNCTION>
<FUNCTION>
<NAME>rm_action_get_description</NAME>
<RETURNS>gchar  *</RETURNS>
RmAction *action
</FUNCTION>
<FUNCTION>
<NAME>rm_action_set_exec</NAME>
<RETURNS>void  </RETURNS>
RmAction *action, const gchar *exec
</FUNCTION>
<FUNCTION>
<NAME>rm_action_get_exec</NAME>
<RETURNS>gchar  *</RETURNS>
RmAction *action
</FUNCTION>
<FUNCTION>
<NAME>rm_action_set_numbers</NAME>
<RETURNS>void  </RETURNS>
RmAction *action, const gchar **numbers
</FUNCTION>
<FUNCTION>
<NAME>rm_action_get_numbers</NAME>
<RETURNS>gchar  **</RETURNS>
RmAction *action
</FUNCTION>
<ENUM>
<NAME>number_format</NAME>
enum number_format {
	NUMBER_FORMAT_UNKNOWN,
	NUMBER_FORMAT_LOCAL,
	NUMBER_FORMAT_NATIONAL,
	NUMBER_FORMAT_INTERNATIONAL,
	NUMBER_FORMAT_INTERNATIONAL_PLUS
};
</ENUM>
<STRUCT>
<NAME>call</NAME>
struct call {
	gint type;
	gchar *date_time;
	gchar *duration;

	struct contact *remote;
	struct contact *local;

	/* Private (e.g. original filename) */
	gchar *priv;
};
</STRUCT>
<STRUCT>
<NAME>call_by_call_entry</NAME>
struct call_by_call_entry {
	gchar *country_code;
	gchar *prefix;
	gint prefix_length;
};
</STRUCT>
<FUNCTION>
<NAME>call_add</NAME>
<RETURNS>GSList  *</RETURNS>
GSList *journal, gint type, const gchar *date_time, const gchar *remote_name, const gchar *remote_number, const gchar *local_name, const gchar *local_number, const gchar *duration, gpointer priv
</FUNCTION>
<FUNCTION>
<NAME>call_free</NAME>
<RETURNS>void  </RETURNS>
gpointer data
</FUNCTION>
<FUNCTION>
<NAME>rm_call_scramble_number</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>call_full_number</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *number, gboolean country_code_prefix
</FUNCTION>
<FUNCTION>
<NAME>call_sort_by_date</NAME>
<RETURNS>gint  </RETURNS>
gconstpointer a, gconstpointer b
</FUNCTION>
<FUNCTION>
<NAME>call_format_number</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile, const gchar *number, enum number_format output_format
</FUNCTION>
<FUNCTION>
<NAME>call_canonize_number</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *number
</FUNCTION>
<MACRO>
<NAME>AUDIO_OUTPUT</NAME>
#define AUDIO_OUTPUT 0
</MACRO>
<MACRO>
<NAME>AUDIO_INPUT</NAME>
#define AUDIO_INPUT  1
</MACRO>
<STRUCT>
<NAME>audio</NAME>
struct audio {
	/* Name of plugin */
	const gchar *name;
	/* Initialize function */
	gboolean (*init)(guchar channels, gushort rate, guchar bits);
	/* Open device for playback */
	gpointer (*open)(void);
	/* Write data to audio device */
	gsize (*write)(gpointer priv, guchar *buffer, gsize len);
	/* Read data of audio device */
	gsize (*read)(gpointer priv, guchar *buffer, gsize max_len);
	/* Close audio device */
	gboolean (*close)(gpointer priv);
	/* Shutdown audio device */
	gboolean (*deinit)(void);
	/* Get possible audio input/output devices */
	GSList *(*get_devices)(void);
};
</STRUCT>
<STRUCT>
<NAME>audio_device</NAME>
struct audio_device {
	gchar *name;
	gchar *internal_name;
	gchar type;
};
</STRUCT>
<FUNCTION>
<NAME>routermanager_audio_register</NAME>
<RETURNS>void  </RETURNS>
struct audio *audio
</FUNCTION>
<FUNCTION>
<NAME>audio_get_default</NAME>
<RETURNS>struct audio  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>audio_open</NAME>
<RETURNS>gpointer  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>audio_read</NAME>
<RETURNS>gsize  </RETURNS>
gpointer audio_priv, guchar *data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>audio_write</NAME>
<RETURNS>gsize  </RETURNS>
gpointer audio_priv, guchar *data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>audio_close</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer audio_priv
</FUNCTION>
<FUNCTION>
<NAME>audio_get_plugins</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>audio_set_default</NAME>
<RETURNS>void  </RETURNS>
gchar *name
</FUNCTION>
<FUNCTION>
<NAME>audio_init</NAME>
<RETURNS>void  </RETURNS>
struct profile *profile
</FUNCTION>
<MACRO>
<NAME>_</NAME>
#define _(text) gettext(text)
</MACRO>
<MACRO>
<NAME>RM_SCHEME</NAME>
#define RM_SCHEME "org.tabos.routermanager"
</MACRO>
<MACRO>
<NAME>RM_SCHEME_PROFILE</NAME>
#define RM_SCHEME_PROFILE "org.tabos.routermanager.profile"
</MACRO>
<MACRO>
<NAME>RM_SCHEME_PROFILE_ACTION</NAME>
#define RM_SCHEME_PROFILE_ACTION "org.tabos.routermanager.profile.action"
</MACRO>
<MACRO>
<NAME>RM_PATH</NAME>
#define RM_PATH "/org/tabos/routermanager/"
</MACRO>
<MACRO>
<NAME>RM_ERROR</NAME>
#define RM_ERROR rm_print_error_quark()
</MACRO>
<ENUM>
<NAME>rm_error</NAME>
typedef enum {
	RM_ERROR_FAX,
	RM_ERROR_ROUTER,
	RM_ERROR_AUDIO,
} rm_error;
</ENUM>
<FUNCTION>
<NAME>rm_print_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_new</NAME>
<RETURNS>gboolean  </RETURNS>
gboolean debug, GError **error
</FUNCTION>
<FUNCTION>
<NAME>rm_init</NAME>
<RETURNS>gboolean  </RETURNS>
GError **error
</FUNCTION>
<FUNCTION>
<NAME>rm_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_get_directory</NAME>
<RETURNS>gchar  *</RETURNS>
gchar *type
</FUNCTION>
<FUNCTION>
<NAME>rm_set_requested_profile</NAME>
<RETURNS>void  </RETURNS>
gchar *name
</FUNCTION>
<FUNCTION>
<NAME>rm_get_requested_profile</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>device_fax</NAME>
struct device_fax {
	gchar *name;
	struct connection *(*send)(gchar *tiff, const gchar *target, gboolean anonymous);
	gboolean (*get_status)(struct fax_status *status);
	gint (*pickup)(struct connection *connection);
	void (*hangup)(struct connection *connection);

	gboolean (*number_is_handled)(gchar *number);
};
</STRUCT>
<FUNCTION>
<NAME>fax_register</NAME>
<RETURNS>void  </RETURNS>
struct device_fax *fax
</FUNCTION>
<FUNCTION>
<NAME>fax_get_plugins</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>file_save</NAME>
<RETURNS>void  </RETURNS>
gchar *name, const gchar *data, gsize len
</FUNCTION>
<FUNCTION>
<NAME>file_load</NAME>
<RETURNS>gchar  *</RETURNS>
gchar *name, gsize *size
</FUNCTION>
<STRUCT>
<NAME>password_manager</NAME>
struct password_manager {
	const gchar *name;
	void (*set_password)(struct profile *profile, const gchar *name, const gchar *password);
	gchar *(*get_password)(struct profile *profile, const gchar *name);
	gboolean (*remove_password)(struct profile *profile, const gchar *name);
};
</STRUCT>
<FUNCTION>
<NAME>password_manager_set_password</NAME>
<RETURNS>void  </RETURNS>
struct profile *profile, const gchar *name, const gchar *password
</FUNCTION>
<FUNCTION>
<NAME>password_manager_get_password</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>password_manager_remove_password</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>password_manager_register</NAME>
<RETURNS>void  </RETURNS>
struct password_manager *manager
</FUNCTION>
<FUNCTION>
<NAME>password_manager_get_plugins</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>password_manager_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>password_encode</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *in
</FUNCTION>
<FUNCTION>
<NAME>password_decode</NAME>
<RETURNS>guchar  *</RETURNS>
const gchar *in
</FUNCTION>
<MACRO>
<NAME>ROUTER_ENABLE_TELNET</NAME>
#define ROUTER_ENABLE_TELNET	"#96*5*"
</MACRO>
<MACRO>
<NAME>ROUTER_ENABLE_CAPI</NAME>
#define ROUTER_ENABLE_CAPI		"#96*3*"
</MACRO>
<ENUM>
<NAME>phone_ports</NAME>
enum phone_ports {
	PORT_SOFTPHONE,
	PORT_ANALOG1,
	PORT_ANALOG2,
	PORT_ANALOG3,
	PORT_ISDNALL,
	PORT_ISDN1,
	PORT_ISDN2,
	PORT_ISDN3,
	PORT_ISDN4,
	PORT_ISDN5,
	PORT_ISDN6,
	PORT_ISDN7,
	PORT_ISDN8,
	PORT_DECT1,
	PORT_DECT2,
	PORT_DECT3,
	PORT_DECT4,
	PORT_DECT5,
	PORT_DECT6,
	PORT_IP1,
	PORT_IP2,
	PORT_IP3,
	PORT_IP4,
	PORT_IP5,
	PORT_IP6,
	PORT_IP7,
	PORT_IP8,
	PORT_IP9,
	PORT_IP10,
	PORT_MAX
};
</ENUM>
<ENUM>
<NAME>phone_number_type</NAME>
enum phone_number_type {
	PHONE_NUMBER_HOME,
	PHONE_NUMBER_WORK,
	PHONE_NUMBER_MOBILE,
	PHONE_NUMBER_FAX_HOME,
	PHONE_NUMBER_FAX_WORK,
	PHONE_NUMBER_PAGER,
};
</ENUM>
<ENUM>
<NAME>router_dial_port</NAME>
enum router_dial_port {
	ROUTER_DIAL_PORT_AUTO = -1,
};
</ENUM>
<STRUCT>
<NAME>phone</NAME>
struct phone {
	gchar *name;
	gint type;
};
</STRUCT>
<STRUCT>
<NAME>phone_number</NAME>
struct phone_number {
	enum phone_number_type type;
	gchar *number;
};
</STRUCT>
<STRUCT>
<NAME>phone_port</NAME>
struct phone_port {
	gchar *name;
	gint type;
	gint number;
};
</STRUCT>
<STRUCT>
<NAME>router_info</NAME>
struct router_info {
	gchar *host;
	gchar *user;
	gchar *password;
	gchar *name;
	gchar *version;
	gchar *serial;
	gchar *session_id;
	gchar *lang;
	gchar *annex;

	/* Extend */
	gint box_id;
	gint maj_ver_id;
	gint min_ver_id;
	GTimer *session_timer;
};
</STRUCT>
<STRUCT>
<NAME>router</NAME>
struct router {
	const gchar *name;
	gboolean (*present)(struct router_info *router_info);
	gboolean (*login)(struct profile *profile);
	gboolean (*logout)(struct profile *profile, gboolean force);
	gboolean (*get_settings)(struct profile *profile);
	gboolean (*load_journal)(struct profile *profile, gchar **data);
	gboolean (*clear_journal)(struct profile *profile);
	gboolean (*dial_number)(struct profile *profile, gint port, const gchar *number);
	gboolean (*hangup)(struct profile *profile, gint port, const gchar *number);
	gchar *(*load_fax)(struct profile *profile, const gchar *filename, gsize *len);
	gchar *(*load_voice)(struct profile *profile, const gchar *filename, gsize *len);
	gchar *(*get_ip)(struct profile *profile);
	gboolean (*reconnect)(struct profile *profile);
	gboolean (*delete_fax)(struct profile *profile, const gchar *filename);
	gboolean (*delete_voice)(struct profile *profile, const gchar *filename);
};
</STRUCT>
<FUNCTION>
<NAME>router_present</NAME>
<RETURNS>gboolean  </RETURNS>
struct router_info *router_info
</FUNCTION>
<FUNCTION>
<NAME>router_login</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_logout</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_settings</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_name</NAME>
<RETURNS>const gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_version</NAME>
<RETURNS>const gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_host</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_login_password</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_login_user</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_ftp_password</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_ftp_user</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_load_journal</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_clear_journal</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_dial_number</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>router_hangup</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>router_get_ip</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_reconnect</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_delete_fax</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>router_delete_voice</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>router_get_area_code</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_country_code</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_international_prefix</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_national_prefix</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>router_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>router_get_phone_list</NAME>
<RETURNS>GSList  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_get_numbers</NAME>
<RETURNS>gchar  **</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_process_journal</NAME>
<RETURNS>void  </RETURNS>
GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>routermanager_router_register</NAME>
<RETURNS>gboolean  </RETURNS>
struct router *router_new
</FUNCTION>
<FUNCTION>
<NAME>router_load_fax</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile, const gchar *filename, gsize *len
</FUNCTION>
<FUNCTION>
<NAME>router_load_voice</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile, const gchar *filename, gsize *len
</FUNCTION>
<FUNCTION>
<NAME>router_info_free</NAME>
<RETURNS>gboolean  </RETURNS>
struct router_info *info
</FUNCTION>
<FUNCTION>
<NAME>router_is_cable</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_load_fax_reports</NAME>
<RETURNS>GSList  *</RETURNS>
struct profile *profile, GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>router_load_voice_records</NAME>
<RETURNS>GSList  *</RETURNS>
struct profile *profile, GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>router_free_phone_list</NAME>
<RETURNS>void  </RETURNS>
GSList *phone_list
</FUNCTION>
<FUNCTION>
<NAME>router_get_phone_port</NAME>
<RETURNS>gint  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_set_phone_port</NAME>
<RETURNS>void  </RETURNS>
struct profile *profile, gint port
</FUNCTION>
<FUNCTION>
<NAME>router_get_suppress_state</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>router_release_lock</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>router_is_locked</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>address_book</NAME>
struct address_book {
	gchar *name;
	gchar *(*get_active_book_name)(void);
	GSList *(*get_contacts)(void);
	gboolean (*reload_contacts)(void);
	gboolean (*remove_contact)(struct contact *contact);
	gboolean (*save_contact)(struct contact *contact);
};
</STRUCT>
<FUNCTION>
<NAME>address_book_available</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_address_book_get_contacts</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>address_book_reload_contacts</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>address_book_remove_contact</NAME>
<RETURNS>gboolean  </RETURNS>
struct contact *contact
</FUNCTION>
<FUNCTION>
<NAME>address_book_save_contact</NAME>
<RETURNS>gboolean  </RETURNS>
struct contact *contact
</FUNCTION>
<FUNCTION>
<NAME>address_book_can_save</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>routermanager_address_book_register</NAME>
<RETURNS>void  </RETURNS>
struct address_book *book
</FUNCTION>
<FUNCTION>
<NAME>routermanager_address_book_unregister</NAME>
<RETURNS>void  </RETURNS>
struct address_book *book
</FUNCTION>
<FUNCTION>
<NAME>address_book_get_name</NAME>
<RETURNS>gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_address_book_get_plugins</NAME>
<RETURNS>GSList  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>rm_settings_new</NAME>
<RETURNS>GSettings  *</RETURNS>
gchar *scheme, gchar *root_path, gchar *file
</FUNCTION>
<FUNCTION>
<NAME>rm_settings_plugin_new</NAME>
<RETURNS>GSettings  *</RETURNS>
gchar *scheme, gchar *file
</FUNCTION>
<FUNCTION>
<NAME>rm_settings_new_with_path</NAME>
<RETURNS>GSettings  *</RETURNS>
gchar *scheme, gchar *path, gchar *file
</FUNCTION>
<USER_FUNCTION>
<NAME>net_connect_func</NAME>
<RETURNS>gboolean </RETURNS>
gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>net_disconnect_func</NAME>
<RETURNS>gboolean </RETURNS>
gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>net_event</NAME>
struct net_event {
	net_connect_func connect;
	net_disconnect_func disconnect;
	gboolean is_connected;
	gpointer user_data;
};
</STRUCT>
<FUNCTION>
<NAME>net_monitor_init</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>net_monitor_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>net_monitor_state_changed</NAME>
<RETURNS>void  </RETURNS>
gboolean state
</FUNCTION>
<FUNCTION>
<NAME>net_add_event</NAME>
<RETURNS>gconstpointer  </RETURNS>
net_connect_func connect, net_disconnect_func disconnect, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>net_remove_event</NAME>
<RETURNS>void  </RETURNS>
gconstpointer net_event_id
</FUNCTION>
<FUNCTION>
<NAME>net_is_online</NAME>
<RETURNS>gboolean  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>net_monitor_reconnect</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>xml_node_type</NAME>
typedef enum {
	XMLNODE_TYPE_TAG,
	XMLNODE_TYPE_ATTRIB,
	XMLNODE_TYPE_DATA
} xml_node_type;
</ENUM>
<STRUCT>
<NAME>xmlnode</NAME>
typedef struct xml_node {
	gchar *name;
	gchar *xml_ns;
	xml_node_type type;
	gchar *data;
	size_t data_size;
	struct xml_node *parent;
	struct xml_node *child;
	struct xml_node *last_child;
	struct xml_node *next;
	gchar *prefix;
	GHashTable *namespace_map;
} xmlnode;
</STRUCT>
<FUNCTION>
<NAME>xmlnode_new</NAME>
<RETURNS>xmlnode  *</RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_new_child</NAME>
<RETURNS>xmlnode  *</RETURNS>
xmlnode *parent, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>read_xml_from_file</NAME>
<RETURNS>xmlnode  *</RETURNS>
const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_get_child</NAME>
<RETURNS>xmlnode  *</RETURNS>
const xmlnode *parent, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_get_next_twin</NAME>
<RETURNS>xmlnode  *</RETURNS>
xmlnode *node
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_get_data</NAME>
<RETURNS>gchar  *</RETURNS>
xmlnode *node
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_get_attrib</NAME>
<RETURNS>const gchar  *</RETURNS>
xmlnode *node, const gchar *attr
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_from_str</NAME>
<RETURNS>xmlnode  *</RETURNS>
const char *str, gssize size
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_insert_data</NAME>
<RETURNS>void  </RETURNS>
xmlnode *node, const gchar *data, gssize size
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_free</NAME>
<RETURNS>void  </RETURNS>
xmlnode *node
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_set_attrib</NAME>
<RETURNS>void  </RETURNS>
xmlnode *node, const gchar *attr, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_insert_child</NAME>
<RETURNS>void  </RETURNS>
xmlnode *parent, xmlnode *child
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_to_formatted_str</NAME>
<RETURNS>gchar  *</RETURNS>
xmlnode *node, gint *len
</FUNCTION>
<FUNCTION>
<NAME>xmlnode_copy</NAME>
<RETURNS>xmlnode  *</RETURNS>
const xmlnode *node
</FUNCTION>
<FUNCTION>
<NAME>emit_connection_notify</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>rm_emit_contact_process</NAME>
<RETURNS>void  </RETURNS>
struct contact *contact
</FUNCTION>
<FUNCTION>
<NAME>emit_journal_loaded</NAME>
<RETURNS>void  </RETURNS>
GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>emit_fax_process</NAME>
<RETURNS>void  </RETURNS>
const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>emit_connection_established</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>emit_connection_terminated</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>emit_connection_status</NAME>
<RETURNS>void  </RETURNS>
gint status, struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>emit_message</NAME>
<RETURNS>void  </RETURNS>
gchar *title, gchar *message
</FUNCTION>
<FUNCTION>
<NAME>emit_contacts_changed</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>emit_authenticate</NAME>
<RETURNS>void  </RETURNS>
struct auth_data *auth_data
</FUNCTION>
<STRUCT>
<NAME>contact_address</NAME>
struct contact_address {
	gint type;
	gchar *street;
	gchar *zip;
	gchar *city;
};
</STRUCT>
<STRUCT>
<NAME>RmContact</NAME>
typedef struct contact {
	/* Name */
	gchar *name;
	/* Picture */
	gpointer image;
	/* Picture len */
	gsize image_len;
	/* Picture URI for online services */
	gchar *image_uri;

#if 1
	/* currently active number */
	gchar *number;
	gchar *company;
	gchar *street;
	gchar *zip;
	gchar *city;
	gboolean lookup;
#endif

	/* Phone numbers */
	GSList *numbers;
	/* Addresses */
	GSList *addresses;

	/* Private data */
	gpointer priv;
} RmContact;
</STRUCT>
<FUNCTION>
<NAME>contact_copy</NAME>
<RETURNS>void  </RETURNS>
struct contact *src, struct contact *dst
</FUNCTION>
<FUNCTION>
<NAME>contact_dup</NAME>
<RETURNS>struct contact  *</RETURNS>
struct contact *src
</FUNCTION>
<FUNCTION>
<NAME>contact_name_compare</NAME>
<RETURNS>gint  </RETURNS>
gconstpointer a, gconstpointer b
</FUNCTION>
<FUNCTION>
<NAME>contact_find_by_number</NAME>
<RETURNS>struct contact  *</RETURNS>
gchar *number
</FUNCTION>
<FUNCTION>
<NAME>contact_free</NAME>
<RETURNS>void  </RETURNS>
struct contact *contact
</FUNCTION>
<FUNCTION>
<NAME>log_save_data</NAME>
<RETURNS>void  </RETURNS>
gchar *name, const gchar *data, gsize len
</FUNCTION>
<FUNCTION>
<NAME>log_init</NAME>
<RETURNS>void  </RETURNS>
gboolean debug
</FUNCTION>
<FUNCTION>
<NAME>log_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>log_set_level</NAME>
<RETURNS>void  </RETURNS>
GLogLevelFlags level
</FUNCTION>
<MACRO>
<NAME>ROUTERMANAGER_PLUGIN_REGISTER</NAME>
#define ROUTERMANAGER_PLUGIN_REGISTER(TYPE_NAME, TypeName, type_name)			\
	_ROUTERMANAGER_PLUGIN_REGISTER(TYPE_NAME, TypeName, type_name,,)
</MACRO>
<MACRO>
<NAME>ROUTERMANAGER_PLUGIN_REGISTER_CONFIGURABLE</NAME>
#define ROUTERMANAGER_PLUGIN_REGISTER_CONFIGURABLE(TYPE_NAME, TypeName, type_name)	\
	static GtkWidget *impl_create_configure_widget (PeasGtkConfigurable *configurable); \
	static void peas_gtk_configurable_iface_init (PeasGtkConfigurableInterface *iface); \
	_ROUTERMANAGER_PLUGIN_REGISTER(TYPE_NAME, TypeName, type_name,			\
		(G_IMPLEMENT_INTERFACE_DYNAMIC (PEAS_GTK_TYPE_CONFIGURABLE, peas_gtk_configurable_iface_init)), \
		peas_object_module_register_extension_type (module, PEAS_GTK_TYPE_CONFIGURABLE, TYPE_NAME);) \
	static void								\
	peas_gtk_configurable_iface_init (PeasGtkConfigurableInterface *iface)	\
	{									\
		iface->create_configure_widget = impl_create_configure_widget;	\
	}
</MACRO>
<VARIABLE>
<NAME>engine</NAME>
extern PeasEngine *engine;
</VARIABLE>
<FUNCTION>
<NAME>plugins_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>plugins_shutdown</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>plugins_user_plugins</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>routermanager_plugins_add_search_path</NAME>
<RETURNS>void  </RETURNS>
gchar *path
</FUNCTION>
<USER_FUNCTION>
<NAME>lookup_func</NAME>
<RETURNS>gboolean </RETURNS>
gchar *number, gchar **name, gchar **address, gchar **zip, gchar **city
</USER_FUNCTION>
<FUNCTION>
<NAME>routermanager_lookup</NAME>
<RETURNS>gboolean  </RETURNS>
gchar *number, gchar **name, gchar **address, gchar **zip, gchar **city
</FUNCTION>
<FUNCTION>
<NAME>routermanager_lookup_register</NAME>
<RETURNS>gboolean  </RETURNS>
lookup_func func
</FUNCTION>
<FUNCTION>
<NAME>vox_init</NAME>
<RETURNS>gpointer  </RETURNS>
gchar *data, gsize len, GError **error
</FUNCTION>
<FUNCTION>
<NAME>vox_play</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer vox_data
</FUNCTION>
<FUNCTION>
<NAME>vox_stop</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer vox_data
</FUNCTION>
<FUNCTION>
<NAME>vox_playpause</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer vox_data
</FUNCTION>
<FUNCTION>
<NAME>vox_seek</NAME>
<RETURNS>gboolean  </RETURNS>
gpointer vox_data, gdouble pos
</FUNCTION>
<FUNCTION>
<NAME>vox_get_fraction</NAME>
<RETURNS>gint  </RETURNS>
gpointer vox_data
</FUNCTION>
<FUNCTION>
<NAME>vox_get_seconds</NAME>
<RETURNS>gfloat  </RETURNS>
gpointer vox_data
</FUNCTION>
<STRUCT>
<NAME>areacode</NAME>
struct areacode {
	gchar *country;
	gint skip;
	GHashTable *table;
};
</STRUCT>
<FUNCTION>
<NAME>csv_parse_global_areacodes_data</NAME>
<RETURNS>GHashTable  *</RETURNS>
gchar *data
</FUNCTION>
<FUNCTION>
<NAME>secret_get_schema</NAME>
<RETURNS>const SecretSchema  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>SECRET_SCHEMA</NAME>
#define SECRET_SCHEMA  secret_get_schema()
</MACRO>
<FUNCTION>
<NAME>fritzbox_login_04_74</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_get_settings_04_74</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_journal_04_74</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gchar **data_ptr
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_clear_journal_04_74</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<MACRO>
<NAME>CSV_FRITZBOX_JOURNAL_DE</NAME>
#define CSV_FRITZBOX_JOURNAL_DE "Typ;Datum;Name;Rufnummer;Nebenstelle;Eigene Rufnummer;Dauer"
</MACRO>
<MACRO>
<NAME>CSV_FRITZBOX_JOURNAL_EN</NAME>
#define CSV_FRITZBOX_JOURNAL_EN "Type;Date;Name;Number;Extension;Outgoing Caller ID;Duration"
</MACRO>
<MACRO>
<NAME>CSV_FRITZBOX_JOURNAL_EN2</NAME>
#define CSV_FRITZBOX_JOURNAL_EN2 "Type;Date;Name;Number;Extension;Telephone Number;Duration"
</MACRO>
<MACRO>
<NAME>CSV_FRITZBOX_JOURNAL_EN3</NAME>
#define CSV_FRITZBOX_JOURNAL_EN3 "Type;Date;Name;Telephone number;Extension;Telephone number;Duration"
</MACRO>
<FUNCTION>
<NAME>csv_parse_fritzbox_journal_data</NAME>
<RETURNS>GSList  *</RETURNS>
GSList *list, const gchar *data
</FUNCTION>
<MACRO>
<NAME>FIRMWARE_IS</NAME>
#define FIRMWARE_IS(major, minor) (((profile->router_info->maj_ver_id == major) && (profile->router_info->min_ver_id >= minor)) || (profile->router_info->maj_ver_id > major))
</MACRO>
<STRUCT>
<NAME>voice_data</NAME>
struct voice_data {
	/* 0 */
	gint header;
	/* 4 */
	gint index;
	/* 8 (2=own message, 3=remote message) */
	gint type;
	/* 12 */
	guint sub_type;
	/* 16 */
	guint size;
	/* 20 */
	guint duration;
	/* 24 */
	guint status;
	/* 28 */
	guchar tmp0[24];
	/* 52 */
	gchar remote_number[54];
	/* 106 */
	gchar tmp1[18];
	/* 124 */
	gchar file[32];
	/* 151 */
	gchar path[128];
	/* 279 */
	guchar day;
	guchar month;
	guchar year;
	guchar hour;
	guchar minute;
	guchar tmp2[31];
	gchar local_number[24];
	gchar tmp3[4];
};
</STRUCT>
<STRUCT>
<NAME>voice_box</NAME>
struct voice_box {
	gsize len;
	gpointer data;
};
</STRUCT>
<FUNCTION>
<NAME>xml_extract_tags</NAME>
<RETURNS>gchar  **</RETURNS>
const gchar *data, gchar *tag_start, gchar *tag_end
</FUNCTION>
<FUNCTION>
<NAME>xml_extract_tag</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *data, gchar *tag
</FUNCTION>
<FUNCTION>
<NAME>xml_extract_input_value</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *data, gchar *tag
</FUNCTION>
<FUNCTION>
<NAME>xml_extract_input_value_r</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *data, gchar *tag
</FUNCTION>
<FUNCTION>
<NAME>xml_extract_list_value</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *data, gchar *tag
</FUNCTION>
<FUNCTION>
<NAME>html_extract_assignment</NAME>
<RETURNS>gchar  *</RETURNS>
const gchar *data, gchar *tag, gboolean p
</FUNCTION>
<FUNCTION>
<NAME>strv_remove_duplicates</NAME>
<RETURNS>gchar  **</RETURNS>
gchar **numbers
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_present</NAME>
<RETURNS>gboolean  </RETURNS>
struct router_info *router_info
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_logout</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gboolean force
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_read_msn</NAME>
<RETURNS>void  </RETURNS>
struct profile *profile, const gchar *data
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_get_dialport</NAME>
<RETURNS>gint  </RETURNS>
gint type
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_fax</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile, const gchar *filename, gsize *len
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_voice</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile, const gchar *filename, gsize *len
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_voicebox</NAME>
<RETURNS>GSList  *</RETURNS>
GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_faxbox</NAME>
<RETURNS>GSList  *</RETURNS>
GSList *journal
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_find_phone_port</NAME>
<RETURNS>gint  </RETURNS>
gint dial_port
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_get_ip</NAME>
<RETURNS>gchar  *</RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_reconnect</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_delete_fax</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_delete_voice</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, const gchar *filename
</FUNCTION>
<FUNCTION>
<NAME>strv_contains</NAME>
<RETURNS>gboolean  </RETURNS>
const gchar *const *strv, const gchar *str
</FUNCTION>
<VARIABLE>
<NAME>new_str</NAME>
	GString *new_str = g_string_new("");
</VARIABLE>
<FUNCTION>
<NAME>g_string_free</NAME>
<RETURNS>return  </RETURNS>
new_str, FALSE
</FUNCTION>
<VARIABLE>
<NAME>error</NAME>
	GError *error = NULL;
</VARIABLE>
<VARIABLE>
<NAME>ret</NAME>
	gchar *ret = NULL;
</VARIABLE>
<VARIABLE>
<NAME>bin</NAME>
	gchar *bin = g_convert(input, -1, "UTF-16LE", "UTF-8", NULL, &written, &error);
</VARIABLE>
<FUNCTION>
<NAME>fritzbox_get_settings_06_35</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_dial_number_06_35</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_hangup_06_35</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_login_05_50</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_get_settings_05_50</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_journal_cb</NAME>
<RETURNS>void  </RETURNS>
SoupSession *session, SoupMessage *msg, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_journal_05_50</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gchar **data_ptr
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_clear_journal_05_50</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_login</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_get_settings</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_load_journal</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gchar **data_ptr
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_dial_number</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_hangup</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_present_04_00</NAME>
<RETURNS>gboolean  </RETURNS>
struct router_info *router_info
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_login_04_00</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_dial_number_04_00</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_hangup_04_00</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile, gint port, const gchar *number
</FUNCTION>
<FUNCTION>
<NAME>fritzbox_get_settings_query</NAME>
<RETURNS>gboolean  </RETURNS>
struct profile *profile
</FUNCTION>
<FUNCTION>
<NAME>create_table_buffer</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>get_line_level_in</NAME>
<RETURNS>double  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<FUNCTION>
<NAME>get_line_level_out</NAME>
<RETURNS>double  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<FUNCTION>
<NAME>convert_isdn_to_audio</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection, guchar *in_buf, guint in_buf_len, guchar *out_buf, guint *out_buf_len, short *rec_buf
</FUNCTION>
<FUNCTION>
<NAME>convert_audio_to_isdn</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection, guchar *in_buf, guint in_buf_len, guchar *out_buf, guint *out_buf_len, short *rec_buf
</FUNCTION>
<FUNCTION>
<NAME>ringtone_play</NAME>
<RETURNS>void  </RETURNS>
gint type
</FUNCTION>
<FUNCTION>
<NAME>ringtone_stop</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>PHONE_CIP</NAME>
#define PHONE_CIP 0x04
</MACRO>
<FUNCTION>
<NAME>capi_phone_call</NAME>
<RETURNS>struct capi_connection  *</RETURNS>
guchar controller, const gchar *source, const gchar *target, gboolean anonymous
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_mute</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection, gboolean mute
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_hold</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection, gboolean mute
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_record</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection, guchar hold, const gchar *dir
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_send_dtmf_code</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection, guchar code
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_hangup</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_pickup</NAME>
<RETURNS>gint  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_init_data</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_transfer</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *capi_connection, _cmsg message
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_conference</NAME>
<RETURNS>void  </RETURNS>
struct connection *active, struct connection *hold
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_flush</NAME>
<RETURNS>void  </RETURNS>
struct connection *connection
</FUNCTION>
<FUNCTION>
<NAME>recording_write</NAME>
<RETURNS>gint  </RETURNS>
struct recorder *recorder, short *buf, gint size, gint channel
</FUNCTION>
<FUNCTION>
<NAME>capi_phone_init</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>SFF_CIP</NAME>
#define SFF_CIP 0x11
</MACRO>
<FUNCTION>
<NAME>sff_send</NAME>
<RETURNS>struct capi_connection  *</RETURNS>
gchar *tiff_file, gint modem, gint ecm, gint controller, const gchar *src_no, const gchar *trg_no, const gchar *lsi, const gchar *local_header_info, gint call_anonymous
</FUNCTION>
<FUNCTION>
<NAME>sff_init_data</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<FUNCTION>
<NAME>sff_clean</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<MACRO>
<NAME>SPANDSP_EXPOSE_INTERNAL_STRUCTURES</NAME>
#define SPANDSP_EXPOSE_INTERNAL_STRUCTURES
</MACRO>
<MACRO>
<NAME>SPEECH_CIP</NAME>
#define SPEECH_CIP			0x04
</MACRO>
<MACRO>
<NAME>FAX_CIP</NAME>
#define FAX_CIP				0x11
</MACRO>
<ENUM>
<NAME>fax_phase</NAME>
enum fax_phase {
	IDLE = -1,
	CONNECT = 1,
	PHASE_B = 2,
	PHASE_D = 3,
	PHASE_E = 4,
};
</ENUM>
<STRUCT>
<NAME>fax_status</NAME>
struct fax_status {
	gchar tiff_file[256];
	gchar src_no[64];
	gchar trg_no[64];
	gchar ident[64];
	gchar header[64];
	gchar remote_ident[64];

	enum fax_phase phase;
	gint error_code;
	gboolean sending;
	gchar ecm;
	gchar modem;
	gint bitrate;
	gint encoding;
	gint bad_rows;
	gint page_current;
	gint page_total;
	gint bytes_received;
	gint bytes_sent;
	gint bytes_total;
	gboolean manual_hookup;
	gboolean done;
	gboolean progress_status;

	struct capi_connection *connection;

	fax_state_t *fax_state;
};
</STRUCT>
<FUNCTION>
<NAME>fax_send</NAME>
<RETURNS>struct capi_connection  *</RETURNS>
gchar *tiff_file, gint modem, gint ecm, gint controller, gint cip, const gchar *src_no, const gchar *trg_no, const gchar *lsi, const gchar *local_header_info, gint call_anonymous
</FUNCTION>
<FUNCTION>
<NAME>fax_recv</NAME>
<RETURNS>gint  </RETURNS>
const gchar *tiff_file, gint modem, gint ecm, const gchar *src_no, gchar *trg_no, const gchar *lsi, const gchar *local_header_info, gint manual_hookup
</FUNCTION>
<FUNCTION>
<NAME>fax_transfer</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection, _cmsg message
</FUNCTION>
<FUNCTION>
<NAME>fax_clean</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<FUNCTION>
<NAME>fax_spandsp_workaround</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<TYPEDEF>
<NAME>uint16_t</NAME>
typedef unsigned short uint16_t;
</TYPEDEF>
<TYPEDEF>
<NAME>uint32_t</NAME>
typedef unsigned int uint32_t;
</TYPEDEF>
<STRUCT>
<NAME>capi_profile</NAME>
typedef struct capi_profile {
	uint16_t ncontroller;
	uint16_t nbchannel;
	uint32_t goptions;
	uint32_t support1;
	uint32_t support2;
	uint32_t support3;
	uint32_t reserved[6];
	uint32_t manu[5];
} capi_profile;
</STRUCT>
<MACRO>
<NAME>CAPI_CONNECTIONS</NAME>
#define CAPI_CONNECTIONS 5
</MACRO>
<MACRO>
<NAME>CAPI_PACKETS</NAME>
#define CAPI_PACKETS 160
</MACRO>
<MACRO>
<NAME>CAPI_BUFFERCNT</NAME>
#define CAPI_BUFFERCNT 6
</MACRO>
<MACRO>
<NAME>CAPI_BCHANNELS</NAME>
#define CAPI_BCHANNELS 2
</MACRO>
<MACRO>
<NAME>USE_ISDN_MUTEX</NAME>
#define USE_ISDN_MUTEX 1
</MACRO>
<MACRO>
<NAME>isdn_lock</NAME>
#define isdn_lock() do { g_mutex_lock(&session->isdn_mutex); } while (0);
</MACRO>
<MACRO>
<NAME>isdn_unlock</NAME>
#define isdn_unlock() do { g_mutex_unlock(&session->isdn_mutex); } while (0);
</MACRO>
<MACRO>
<NAME>CREATE_THREAD</NAME>
#define CREATE_THREAD(name, func, data) g_thread_new(name, func, data)
</MACRO>
<ENUM>
<NAME>state</NAME>
enum state {
	STATE_IDLE = 0,
	STATE_CONNECT_REQ,
	STATE_CONNECT_WAIT,
	STATE_CONNECT_ACTIVE,
	STATE_CONNECT_B3_WAIT,
	STATE_CONNECTED,
	STATE_DISCONNECT_B3_REQ,
	STATE_DISCONNECT_B3_WAIT,
	STATE_DISCONNECT_ACTIVE,
	STATE_DISCONNET_WAIT,
	STATE_RINGING,
	STATE_INCOMING_WAIT,
	STATE_MAXSTATE
};
</ENUM>
<ENUM>
<NAME>session_type</NAME>
enum session_type {
	SESSION_NONE,
	SESSION_FAX,
	SESSION_PHONE,
	SESSION_SFF
};
</ENUM>
<MACRO>
<NAME>RECORDING_BUFSIZE</NAME>
#define RECORDING_BUFSIZE 32768
</MACRO>
<MACRO>
<NAME>RECORDING_JITTER</NAME>
#define RECORDING_JITTER 200
</MACRO>
<ENUM>
<NAME>recording</NAME>
enum recording {
	RECORDING_LOCAL,
	RECORDING_REMOTE
};
</ENUM>
<STRUCT>
<NAME>record_channel</NAME>
struct record_channel {
	gint64 position;
	short buffer[RECORDING_BUFSIZE];
};
</STRUCT>
<STRUCT>
<NAME>recorder</NAME>
struct recorder {
	SNDFILE *file;
	char *file_name;

	gint64 start_time;
	struct record_channel local;
	struct record_channel remote;
	gint64 last_write;
};
</STRUCT>
<STRUCT>
<NAME>capi_connection</NAME>
struct capi_connection {
	enum state state;
	enum session_type type;

	unsigned int id;
	unsigned int controller;
	unsigned long int plci;
	unsigned long int ncci;
	gchar *ncpi;
	unsigned int reason;
	unsigned int reason_b3;
	char *source;
	char *target;
	void *priv;
	int early_b3;
	int hold;
	time_t connect_time;
	int mute;
	int recording;
	double line_level_in_state;
	double line_level_out_state;
	struct recorder recorder;
	int buffers;
	gboolean use_buffers;

	gpointer audio;

	void (*init_data)(struct capi_connection *connection);
	void (*data)(struct capi_connection *connection, _cmsg capi_message);
	void (*clean)(struct capi_connection *connection);
};
</STRUCT>
<STRUCT>
<NAME>session_handlers</NAME>
struct session_handlers {
	gpointer (*audio_open)(void);
	gsize (*audio_input)(gpointer audio, guchar *buf, gsize len);
	gsize (*audio_output)(gpointer audio, guchar *buf, gsize len);
	gboolean (*audio_close)(gpointer audio);

	void (*connected)(struct capi_connection *connection);
	void (*disconnected)(struct capi_connection *connection);
	void (*ring)(struct capi_connection *connection);

	void (*code)(struct capi_connection *connection, int code);

	void (*status)(struct capi_connection *connection, int error_code);
};
</STRUCT>
<STRUCT>
<NAME>session</NAME>
struct session {
	GMutex isdn_mutex;

	struct capi_connection connection[CAPI_CONNECTIONS];
	int appl_id;
	int message_number;
	int input_thread_state;

	struct session_handlers *handlers;
};
</STRUCT>
<FUNCTION>
<NAME>capi_get_free_connection</NAME>
<RETURNS>struct capi_connection  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>capi_call</NAME>
<RETURNS>struct capi_connection  *</RETURNS>
unsigned, const char *, const char *, unsigned, unsigned, unsigned, _cword, _cword, _cword, _cstruct, _cstruct, _cstruct
</FUNCTION>
<FUNCTION>
<NAME>capi_send_dtmf_code</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection, unsigned char nCode
</FUNCTION>
<FUNCTION>
<NAME>capi_hangup</NAME>
<RETURNS>void  </RETURNS>
struct capi_connection *connection
</FUNCTION>
<FUNCTION>
<NAME>capi_pickup</NAME>
<RETURNS>int  </RETURNS>
struct capi_connection *connection, int type
</FUNCTION>
<FUNCTION>
<NAME>capi_get_session</NAME>
<RETURNS>struct session  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>capi_session_init</NAME>
<RETURNS>struct session  *</RETURNS>
struct session_handlers *handlers, const char *host, gint controller
</FUNCTION>
<FUNCTION>
<NAME>capi_session_close</NAME>
<RETURNS>int  </RETURNS>
int force
</FUNCTION>
<STRUCT>
<NAME>lookup</NAME>
struct lookup {
	gboolean prefix;
	gchar *service;
	gchar *url;
	gchar *pattern;
	gchar **name;
	gchar **street;
	gchar **city;
	gint zip_len;
};
</STRUCT>
