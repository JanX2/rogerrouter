<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository version="1.2"
            xmlns="http://www.gtk.org/introspection/core/1.0"
            xmlns:c="http://www.gtk.org/introspection/c/1.0"
            xmlns:glib="http://www.gtk.org/introspection/glib/1.0">
  <include name="GIRepository" version="2.0"/>
  <include name="GModule" version="2.0"/>
  <include name="GObject" version="2.0"/>
  <include name="Gio" version="2.0"/>
  <package name="libpeas-1.0"/>
  <c:include name="libpeas/peas.h"/>
  <namespace name="Peas"
             version="1.0"
             shared-library="libpeas-1.0.so.0"
             c:identifier-prefixes="Peas"
             c:symbol-prefixes="peas">
    <alias name="Extension" c:type="PeasExtension">
      <doc xml:space="preserve">A proxy class to access the actual plugin.</doc>
      <type name="GObject.Object" c:type="GObject"/>
    </alias>
    <interface name="Activatable"
               c:symbol-prefix="activatable"
               c:type="PeasActivatable"
               glib:type-name="PeasActivatable"
               glib:get-type="peas_activatable_get_type"
               glib:type-struct="ActivatableInterface">
      <doc xml:space="preserve">Interface for activatable plugins.</doc>
      <virtual-method name="activate" invoker="activate">
        <doc xml:space="preserve">Activates the extension on the targetted object.

On activation, the extension should hook itself to the object
where it makes sense.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="activatable" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasActivatable.</doc>
            <type name="Activatable" c:type="PeasActivatable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="deactivate" invoker="deactivate">
        <doc xml:space="preserve">Deactivates the extension on the targetted object.

On deactivation, an extension should remove itself from all the hooks it
used and should perform any cleanup required, so it can be unreffed safely
and without any more effect on the host application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="activatable" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasActivatable.</doc>
            <type name="Activatable" c:type="PeasActivatable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="update_state" invoker="update_state">
        <doc xml:space="preserve">Triggers an update of the extension internal state to take into account
state changes in the targetted object, due to some event or user action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="activatable" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasActivatable.</doc>
            <type name="Activatable" c:type="PeasActivatable*"/>
          </instance-parameter>
        </parameters>
      </virtual-method>
      <method name="activate" c:identifier="peas_activatable_activate">
        <doc xml:space="preserve">Activates the extension on the targetted object.

On activation, the extension should hook itself to the object
where it makes sense.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="activatable" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasActivatable.</doc>
            <type name="Activatable" c:type="PeasActivatable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="deactivate" c:identifier="peas_activatable_deactivate">
        <doc xml:space="preserve">Deactivates the extension on the targetted object.

On deactivation, an extension should remove itself from all the hooks it
used and should perform any cleanup required, so it can be unreffed safely
and without any more effect on the host application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="activatable" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasActivatable.</doc>
            <type name="Activatable" c:type="PeasActivatable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="update_state" c:identifier="peas_activatable_update_state">
        <doc xml:space="preserve">Triggers an update of the extension internal state to take into account
state changes in the targetted object, due to some event or user action.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="activatable" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasActivatable.</doc>
            <type name="Activatable" c:type="PeasActivatable*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="object"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The object property contains the targetted object for this
#PeasActivatable instance, for example a toplevel window in a typical
windowed application. It is set at construction time and won't change.</doc>
        <type name="GObject.Object"/>
      </property>
    </interface>
    <record name="ActivatableInterface"
            c:type="PeasActivatableInterface"
            glib:is-gtype-struct-for="Activatable">
      <doc xml:space="preserve">Provides an interface for activatable plugins.</doc>
      <field name="g_iface">
        <doc xml:space="preserve">The parent interface.</doc>
        <type name="GObject.TypeInterface" c:type="GTypeInterface"/>
      </field>
      <field name="activate">
        <callback name="activate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="activatable" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasActivatable.</doc>
              <type name="Activatable" c:type="PeasActivatable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="deactivate">
        <callback name="deactivate">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="activatable" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasActivatable.</doc>
              <type name="Activatable" c:type="PeasActivatable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="update_state">
        <callback name="update_state">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="activatable" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasActivatable.</doc>
              <type name="Activatable" c:type="PeasActivatable*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
    </record>
    <class name="Engine"
           c:symbol-prefix="engine"
           c:type="PeasEngine"
           parent="GObject.Object"
           glib:type-name="PeasEngine"
           glib:get-type="peas_engine_get_type"
           glib:type-struct="EngineClass">
      <doc xml:space="preserve">The #PeasEngine structure contains only private data and should only be
accessed using the provided API.</doc>
      <constructor name="new" c:identifier="peas_engine_new">
        <doc xml:space="preserve">Return a new instance of #PeasEngine.
If no default #PeasEngine has been instantiated yet,
the first call of this function will set the default
engine as the new instance of #PeasEngine.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #PeasEngine.</doc>
          <type name="Engine" c:type="PeasEngine*"/>
        </return-value>
      </constructor>
      <constructor name="new_with_nonglobal_loaders"
                   c:identifier="peas_engine_new_with_nonglobal_loaders"
                   version="1.14">
        <doc xml:space="preserve">Return a new instance of #PeasEngine which will use non-global
plugin loaders instead of the default global ones. This allows
multiple threads to each have a #PeasEngine and be used without
internal locking.

Note: due to CPython's GIL the python and python3
      plugin loaders are always global.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #PeasEngine that uses non-global loaders.</doc>
          <type name="Engine" c:type="PeasEngine*"/>
        </return-value>
      </constructor>
      <function name="get_default" c:identifier="peas_engine_get_default">
        <doc xml:space="preserve">Return the existing instance of #PeasEngine or a subclass of it.
If no #PeasEngine subclass has been instantiated yet, the first call
of this function will return a new instance of #PeasEngine.

Note: this function should never be used when multiple threads are
      using libpeas API as it is not thread-safe.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the existing instance of #PeasEngine.</doc>
          <type name="Engine" c:type="PeasEngine*"/>
        </return-value>
      </function>
      <virtual-method name="load_plugin" invoker="load_plugin">
        <doc xml:space="preserve">Loads the plugin corresponding to @info if it's not currently loaded.
Emits the "load-plugin" signal; loading the plugin
actually occurs in the default signal handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="unload_plugin" invoker="unload_plugin">
        <doc xml:space="preserve">Unloads the plugin corresponding to @info.
Emits the "unload-plugin" signal; unloading the plugin
actually occurs in the default signal handler.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="add_search_path"
              c:identifier="peas_engine_add_search_path">
        <doc xml:space="preserve">This function appends a search path to the list of paths where to
look for plugins.

A so-called "search path" actually consists of both a
module directory (where the shared libraries or language modules
lie) and a data directory (where the plugin data is).

The plugin will be able to use a correct data dir depending on
where it is installed, hence allowing to keep the plugin agnostic
when it comes to installation location: the same plugin can be
installed either in the system path or in the user's home directory,
without taking other special care than using
peas_plugin_info_get_data_dir() when looking for its data files.

If @data_dir is %NULL, then it is set to the same value as
@module_dir.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="module_dir" transfer-ownership="none">
            <doc xml:space="preserve">the plugin module directory.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="data_dir"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the plugin data directory.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_extension"
              c:identifier="peas_engine_create_extension"
              shadowed-by="create_extensionv"
              introspectable="0">
        <doc xml:space="preserve">If the plugin identified by @info implements the @extension_type interface,
then this function will return a new instance of this implementation,
wrapped in a new #PeasExtension instance. Otherwise, it will return %NULL.

When creating the new instance of the @extension_type subtype, the
provided construct properties will be passed to the extension construction
handler (exactly like if you had called g_object_new() yourself).

The new extension instance produced by this function will always be
returned wrapped in a #PeasExtension proxy, following the current libpeas
principle of never giving you the actual object (also because it might as
well *not* be an actual object).</doc>
        <return-value>
          <doc xml:space="preserve">a new instance of #PeasExtension wrapping
the @extension_type instance, or %NULL.</doc>
          <type name="Extension" c:type="PeasExtension*"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A loaded #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">The implemented extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed optionally by more
  name/value pairs, followed by %NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </method>
      <method name="create_extension_valist"
              c:identifier="peas_engine_create_extension_valist"
              introspectable="0">
        <doc xml:space="preserve">If the plugin identified by @info implements the @extension_type interface,
then this function will return a new instance of this implementation,
wrapped in a new #PeasExtension instance. Otherwise, it will return %NULL.

See peas_engine_create_extension() for more information.</doc>
        <return-value>
          <doc xml:space="preserve">a new instance of #PeasExtension wrapping
the @extension_type instance, or %NULL.</doc>
          <type name="Extension" c:type="PeasExtension*"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A loaded #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">The implemented extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed optionally by more
  name/value pairs, followed by %NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </method>
      <method name="create_extensionv"
              c:identifier="peas_engine_create_extensionv"
              shadows="create_extension">
        <doc xml:space="preserve">If the plugin identified by @info implements the @extension_type interface,
then this function will return a new instance of this implementation,
wrapped in a new #PeasExtension instance. Otherwise, it will return %NULL.

See peas_engine_create_extension() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #PeasExtension wrapping
the @extension_type instance, or %NULL.</doc>
          <type name="Extension" c:type="PeasExtension*"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A loaded #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">The implemented extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @parameters array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">
  an array of #GParameter.</doc>
            <array length="2" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="enable_loader" c:identifier="peas_engine_enable_loader">
        <doc xml:space="preserve">Enable a loader, enables a loader for plugins.
The C plugin loader is always enabled. The other plugin
loaders are: lua5.1, python and python3.

For instance, the following code will enable Python 2 plugins
to be loaded:
|[
peas_engine_enable_loader (engine, "python");
]|

Note: plugin loaders used to be shared across #PeasEngines so enabling
      a loader on one #PeasEngine would enable it on all #PeasEngines.
      This behavior has been kept to avoid breaking applications,
      however a warning has been added to help applications transition.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="loader_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the loader to enable.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="garbage_collect"
              c:identifier="peas_engine_garbage_collect">
        <doc xml:space="preserve">This function triggers garbage collection on all the loaders currently
owned by the #PeasEngine.  This can be used to force the loaders to destroy
managed objects that still hold references to objects that are about to
disappear.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_loaded_plugins"
              c:identifier="peas_engine_get_loaded_plugins">
        <doc xml:space="preserve">Returns the list of the names of all the loaded plugins, or an array
containing a single %NULL element if there is no plugin currently loaded.

Please note that the returned array is a newly allocated one: you will need
to free it using g_strfreev().</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly-allocated
%NULL-terminated array of strings.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_plugin_info"
              c:identifier="peas_engine_get_plugin_info">
        <doc xml:space="preserve">Gets the #PeasPluginInfo corresponding with @plugin_name,
or %NULL if @plugin_name was not found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #PeasPluginInfo corresponding with
a given plugin module name.</doc>
          <type name="PluginInfo" c:type="PeasPluginInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="plugin_name" transfer-ownership="none">
            <doc xml:space="preserve">A plugin name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_plugin_list"
              c:identifier="peas_engine_get_plugin_list">
        <doc xml:space="preserve">Returns the list of #PeasPluginInfo known to the engine.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a #GList of
#PeasPluginInfo. Note that the list belongs to the engine and should
not be freed.</doc>
          <type name="GLib.List" c:type="const GList*">
            <type name="PluginInfo"/>
          </type>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="load_plugin" c:identifier="peas_engine_load_plugin">
        <doc xml:space="preserve">Loads the plugin corresponding to @info if it's not currently loaded.
Emits the "load-plugin" signal; loading the plugin
actually occurs in the default signal handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the plugin has been successfully loaded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
        </parameters>
      </method>
      <method name="prepend_search_path"
              c:identifier="peas_engine_prepend_search_path"
              version="1.6">
        <doc xml:space="preserve">This function prepends a search path to the list of paths where to
look for plugins.

See Also: peas_engine_add_search_path()</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="module_dir" transfer-ownership="none">
            <doc xml:space="preserve">the plugin module directory.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="data_dir"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">the plugin data directory.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="provides_extension"
              c:identifier="peas_engine_provides_extension">
        <doc xml:space="preserve">Returns if @info provides an extension for @extension_type.
If the @info is not loaded than %FALSE will always be returned.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if @info provides an extension for @extension_type.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">The extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="rescan_plugins" c:identifier="peas_engine_rescan_plugins">
        <doc xml:space="preserve">Rescan all the registered directories to find new or updated plugins.

Calling this function will make the newly installed plugin infos
be loaded by the engine, so the new plugins can be used without
restarting the application.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="set_loaded_plugins"
              c:identifier="peas_engine_set_loaded_plugins">
        <doc xml:space="preserve">Sets the list of loaded plugins for @engine. When this function is called,
the #PeasEngine will load all the plugins whose names are in @plugin_names,
and ensures all other active plugins are unloaded.

If @plugin_names is %NULL, all plugins will be unloaded.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="plugin_names"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A %NULL-terminated
 array of plugin names, or %NULL.</doc>
            <array c:type="gchar**">
              <type name="utf8" c:type="gchar*"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="unload_plugin" c:identifier="peas_engine_unload_plugin">
        <doc xml:space="preserve">Unloads the plugin corresponding to @info.
Emits the "unload-plugin" signal; unloading the plugin
actually occurs in the default signal handler.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the plugin has been successfully unloaded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="engine" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasEngine.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="loaded-plugins" writable="1" transfer-ownership="none">
        <doc xml:space="preserve">The list of loaded plugins.

This will be modified when peas_engine_load_plugin() or
peas_engine_unload_plugin() is called.

This can be used with GSettings to save the loaded plugins by binding
to this property after instantiating the engine by doing:
|[
  g_settings_bind (gsettings_object,
                   LOADED_PLUGINS_KEY,
                   engine,
                   "loaded-plugins",
                   G_SETTINGS_BIND_DEFAULT);
]|

Note: notify will not be called when the engine is being destroyed.</doc>
        <array>
          <type name="utf8"/>
        </array>
      </property>
      <property name="nonglobal-loaders"
                version="1.14"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">If non-global plugin loaders should be used.

See peas_engine_new_with_nonglobal_loaders() for more information.</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="plugin-list" transfer-ownership="none">
        <doc xml:space="preserve">The list of found plugins.

This will be modified when peas_engine_rescan_plugins() is called.

Note: the list belongs to the engine and should not be modified or freed.</doc>
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv" readable="0" private="1">
        <type name="EnginePrivate" c:type="PeasEnginePrivate*"/>
      </field>
      <glib:signal name="load-plugin" when="last">
        <doc xml:space="preserve">The load-plugin signal is emitted when a plugin is being loaded.

The plugin is being loaded in the default handler. Hence, if you want to
perform some action before the plugin is loaded, you should use
g_signal_connect(), but if you want to perform some action *after* the
plugin is loaded (the most common case), you should use
g_signal_connect_after().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="unload-plugin" when="last">
        <doc xml:space="preserve">The unload-plugin signal is emitted when a plugin is being unloaded.

The plugin is being unloaded in the default handler. Hence, if you want
to perform some action before the plugin is unloaded (the most common
case), you should use g_signal_connect(), but if you want to perform some
action after the plugin is unloaded (the most common case), you should
use g_signal_connect_after().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="EngineClass"
            c:type="PeasEngineClass"
            glib:is-gtype-struct-for="Engine">
      <doc xml:space="preserve">Class structure for #PeasEngine.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="load_plugin">
        <callback name="load_plugin">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="engine" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasEngine.</doc>
              <type name="Engine" c:type="PeasEngine*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasPluginInfo.</doc>
              <type name="PluginInfo" c:type="PeasPluginInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="unload_plugin">
        <callback name="unload_plugin">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="engine" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasEngine.</doc>
              <type name="Engine" c:type="PeasEngine*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <doc xml:space="preserve">A #PeasPluginInfo.</doc>
              <type name="PluginInfo" c:type="PeasPluginInfo*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="EnginePrivate" c:type="PeasEnginePrivate" disguised="1">
    </record>
    <class name="ExtensionBase"
           c:symbol-prefix="extension_base"
           c:type="PeasExtensionBase"
           parent="GObject.Object"
           abstract="1"
           glib:type-name="PeasExtensionBase"
           glib:get-type="peas_extension_base_get_type"
           glib:type-struct="ExtensionBaseClass">
      <doc xml:space="preserve">Base class for C extensions.</doc>
      <method name="get_data_dir"
              c:identifier="peas_extension_base_get_data_dir">
        <doc xml:space="preserve">Get the path of the directory where the plugin should look for
its data files.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">A newly allocated string with the path of the
directory where the plugin should look for its data files</doc>
          <type name="utf8" c:type="gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extbase" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasExtensionBase.</doc>
            <type name="ExtensionBase" c:type="PeasExtensionBase*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_plugin_info"
              c:identifier="peas_extension_base_get_plugin_info">
        <doc xml:space="preserve">Get information relative to @extbase.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the #PeasPluginInfo relative
to the #PeasExtensionBase.</doc>
          <type name="PluginInfo" c:type="PeasPluginInfo*"/>
        </return-value>
        <parameters>
          <instance-parameter name="extbase" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasExtensionBase.</doc>
            <type name="ExtensionBase" c:type="PeasExtensionBase*"/>
          </instance-parameter>
        </parameters>
      </method>
      <property name="data-dir" transfer-ownership="none">
        <doc xml:space="preserve">The The full path of the directory where the plugin
should look for its data files.

Note: This is the same path as that returned by
peas_plugin_info_get_data_dir().</doc>
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="plugin-info"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">The #PeasPluginInfo related to the current plugin.</doc>
        <type name="PluginInfo"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ExtensionBasePrivate" c:type="PeasExtensionBasePrivate*"/>
      </field>
    </class>
    <record name="ExtensionBaseClass"
            c:type="PeasExtensionBaseClass"
            glib:is-gtype-struct-for="ExtensionBase">
      <doc xml:space="preserve">The class structure of #PeasExtensionBase.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ExtensionBasePrivate"
            c:type="PeasExtensionBasePrivate"
            disguised="1">
    </record>
    <class name="ExtensionSet"
           c:symbol-prefix="extension_set"
           c:type="PeasExtensionSet"
           parent="GObject.Object"
           glib:type-name="PeasExtensionSet"
           glib:get-type="peas_extension_set_get_type"
           glib:type-struct="ExtensionSetClass">
      <doc xml:space="preserve">The #PeasExtensionSet structure contains only private data and should only
be accessed using the provided API.</doc>
      <constructor name="new"
                   c:identifier="peas_extension_set_new"
                   shadowed-by="newv"
                   introspectable="0">
        <doc xml:space="preserve">Create a new #PeasExtensionSet for the @exten_type extension type.

At any moment, the #PeasExtensionSet will contain an extension instance for
each loaded plugin which implements the @exten_type extension type. It does
so by connecting to the relevant signals from #PeasEngine.

The property values passed to peas_extension_set_new() will be used for the
construction of new extension instances.

If @engine is %NULL, then the default engine will be used.

See peas_engine_create_extension() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #PeasExtensionSet.</doc>
          <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
        </return-value>
        <parameters>
          <parameter name="engine"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #PeasEngine, or %NULL.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </parameter>
          <parameter name="exten_type" transfer-ownership="none">
            <doc xml:space="preserve">the extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="..." transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed optionally by more
  name/value pairs, followed by %NULL.</doc>
            <varargs/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_valist"
                   c:identifier="peas_extension_set_new_valist"
                   introspectable="0">
        <doc xml:space="preserve">Create a new #PeasExtensionSet for the @exten_type extension type.

If @engine is %NULL, then the default engine will be used.

See peas_extension_set_new() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #PeasExtensionSet.</doc>
          <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
        </return-value>
        <parameters>
          <parameter name="engine"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #PeasEngine, or %NULL.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </parameter>
          <parameter name="exten_type" transfer-ownership="none">
            <doc xml:space="preserve">the extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="first_property" transfer-ownership="none">
            <doc xml:space="preserve">the name of the first property.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="var_args" transfer-ownership="none">
            <doc xml:space="preserve">the value of the first property, followed optionally by more
  name/value pairs, followed by %NULL.</doc>
            <type name="va_list" c:type="va_list"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="newv"
                   c:identifier="peas_extension_set_newv"
                   shadows="new">
        <doc xml:space="preserve">Create a new #PeasExtensionSet for the @exten_type extension type.

If @engine is %NULL, then the default engine will be used.

See peas_extension_set_new() for more information.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new instance of #PeasExtensionSet.</doc>
          <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
        </return-value>
        <parameters>
          <parameter name="engine"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">A #PeasEngine, or %NULL.</doc>
            <type name="Engine" c:type="PeasEngine*"/>
          </parameter>
          <parameter name="exten_type" transfer-ownership="none">
            <doc xml:space="preserve">the extension #GType.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">the length of the @parameters array.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">an array of #GParameter.</doc>
            <array length="2" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
        </parameters>
      </constructor>
      <virtual-method name="call">
        <return-value transfer-ownership="none">
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
          </instance-parameter>
          <parameter name="method_name" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="args" transfer-ownership="none">
            <type name="GIRepository.Argument" c:type="GIArgument*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="extension_added">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
          <parameter name="exten" transfer-ownership="none">
            <type name="Extension" c:type="PeasExtension*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <virtual-method name="extension_removed">
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
          <parameter name="exten" transfer-ownership="none">
            <type name="Extension" c:type="PeasExtension*"/>
          </parameter>
        </parameters>
      </virtual-method>
      <method name="foreach"
              c:identifier="peas_extension_set_foreach"
              version="1.2">
        <doc xml:space="preserve">Calls @func for each #PeasExtension.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasExtensionSet.</doc>
            <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
          </instance-parameter>
          <parameter name="func"
                     transfer-ownership="none"
                     scope="call"
                     closure="1">
            <doc xml:space="preserve">A function call for each extension.</doc>
            <type name="ExtensionSetForeachFunc"
                  c:type="PeasExtensionSetForeachFunc"/>
          </parameter>
          <parameter name="data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Optional data to be passed to the function or %NULL.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_extension"
              c:identifier="peas_extension_set_get_extension">
        <doc xml:space="preserve">Returns the #PeasExtension object corresponding to @info, or %NULL
if the plugin doesn't provide such an extension.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a reference to a #PeasExtension or %NULL</doc>
          <type name="Extension" c:type="PeasExtension*"/>
        </return-value>
        <parameters>
          <instance-parameter name="set" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasExtensionSet</doc>
            <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
          </instance-parameter>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">a #PeasPluginInfo</doc>
            <type name="PluginInfo" c:type="PeasPluginInfo*"/>
          </parameter>
        </parameters>
      </method>
      <property name="construct-properties"
                readable="0"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gpointer" c:type="gpointer"/>
      </property>
      <property name="engine"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="Engine"/>
      </property>
      <property name="extension-type"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="GType" c:type="GType"/>
      </property>
      <field name="parent">
        <type name="GObject.Object" c:type="GObject"/>
      </field>
      <field name="priv">
        <type name="ExtensionSetPrivate" c:type="PeasExtensionSetPrivate*"/>
      </field>
      <glib:signal name="extension-added" when="last">
        <doc xml:space="preserve">The extension-added signal is emitted when a new extension has been
added to the #PeasExtensionSet. It happens when a new plugin implementing
the extension set's extension type is loaded.

You should connect to this signal in order to set up the extensions when
they are loaded. Note that this signal is not fired for extensions coming
from plugins that were already loaded when the #PeasExtensionSet instance
was created. You should set those up by yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo"/>
          </parameter>
          <parameter name="exten" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasExtension.</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
      <glib:signal name="extension-removed" when="last">
        <doc xml:space="preserve">The extension-removed signal is emitted when a new extension is about to be
removed from the #PeasExtensionSet. It happens when a plugin implementing
the extension set's extension type is unloaded, or when the
#PeasExtensionSet itself is destroyed.

You should connect to this signal in order to clean up the extensions
when their plugin is unload. Note that this signal is not fired for the
#PeasExtension instances still available when the #PeasExtensionSet
instance is destroyed. You should clean those up by yourself.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo"/>
          </parameter>
          <parameter name="exten" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasExtension.</doc>
            <type name="GObject.Object"/>
          </parameter>
        </parameters>
      </glib:signal>
    </class>
    <record name="ExtensionSetClass"
            c:type="PeasExtensionSetClass"
            glib:is-gtype-struct-for="ExtensionSet">
      <doc xml:space="preserve">The class structure for #PeasExtensionSet.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.ObjectClass" c:type="GObjectClass"/>
      </field>
      <field name="call">
        <callback name="call">
          <return-value transfer-ownership="none">
            <type name="gboolean" c:type="gboolean"/>
          </return-value>
          <parameters>
            <parameter name="set" transfer-ownership="none">
              <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
            </parameter>
            <parameter name="method_name" transfer-ownership="none">
              <type name="utf8" c:type="const gchar*"/>
            </parameter>
            <parameter name="args" transfer-ownership="none">
              <type name="GIRepository.Argument" c:type="GIArgument*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="extension_added">
        <callback name="extension_added">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="set" transfer-ownership="none">
              <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="PluginInfo" c:type="PeasPluginInfo*"/>
            </parameter>
            <parameter name="exten" transfer-ownership="none">
              <type name="Extension" c:type="PeasExtension*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="extension_removed">
        <callback name="extension_removed">
          <return-value transfer-ownership="none">
            <type name="none" c:type="void"/>
          </return-value>
          <parameters>
            <parameter name="set" transfer-ownership="none">
              <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
            </parameter>
            <parameter name="info" transfer-ownership="none">
              <type name="PluginInfo" c:type="PeasPluginInfo*"/>
            </parameter>
            <parameter name="exten" transfer-ownership="none">
              <type name="Extension" c:type="PeasExtension*"/>
            </parameter>
          </parameters>
        </callback>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <callback name="ExtensionSetForeachFunc"
              c:type="PeasExtensionSetForeachFunc"
              version="1.2">
      <doc xml:space="preserve">This function is passed to peas_extension_set_foreach() and
will be called for each extension in @set.</doc>
      <return-value transfer-ownership="none">
        <type name="none" c:type="void"/>
      </return-value>
      <parameters>
        <parameter name="set" transfer-ownership="none">
          <doc xml:space="preserve">A #PeasExtensionSet.</doc>
          <type name="ExtensionSet" c:type="PeasExtensionSet*"/>
        </parameter>
        <parameter name="info" transfer-ownership="none">
          <doc xml:space="preserve">A #PeasPluginInfo.</doc>
          <type name="PluginInfo" c:type="PeasPluginInfo*"/>
        </parameter>
        <parameter name="exten" transfer-ownership="none">
          <doc xml:space="preserve">A #PeasExtension.</doc>
          <type name="Extension" c:type="PeasExtension*"/>
        </parameter>
        <parameter name="data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1">
          <doc xml:space="preserve">Optional data passed to the function.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="ExtensionSetPrivate"
            c:type="PeasExtensionSetPrivate"
            disguised="1">
    </record>
    <callback name="FactoryFunc" c:type="PeasFactoryFunc">
      <doc xml:space="preserve">A #PeasFactoryFunc is a factory function which will instanciate a new
extension of a given type. g_object_newv() is such a function.

It is used with peas_object_module_register_extension_factory().</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The created object.</doc>
        <type name="GObject.Object" c:type="GObject*"/>
      </return-value>
      <parameters>
        <parameter name="n_parameters" transfer-ownership="none">
          <doc xml:space="preserve">The number of paramteters.</doc>
          <type name="guint" c:type="guint"/>
        </parameter>
        <parameter name="parameters" transfer-ownership="none">
          <doc xml:space="preserve">The parameters.</doc>
          <array length="0" zero-terminated="0" c:type="GParameter*">
            <type name="GObject.Parameter" c:type="GParameter"/>
          </array>
        </parameter>
        <parameter name="user_data"
                   transfer-ownership="none"
                   nullable="1"
                   allow-none="1"
                   closure="2">
          <doc xml:space="preserve">Optional data to be passed to the function, or %NULL.</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <class name="ObjectModule"
           c:symbol-prefix="object_module"
           c:type="PeasObjectModule"
           parent="GObject.TypeModule"
           glib:type-name="PeasObjectModule"
           glib:get-type="peas_object_module_get_type"
           glib:type-struct="ObjectModuleClass">
      <doc xml:space="preserve">The #PeasObjectModule structure contains only private data and should only
be accessed using the provided API.</doc>
      <implements name="GObject.TypePlugin"/>
      <constructor name="new"
                   c:identifier="peas_object_module_new"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #PeasObjectModule.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #PeasObjectModule.</doc>
          <type name="ObjectModule" c:type="PeasObjectModule*"/>
        </return-value>
        <parameters>
          <parameter name="module_name" transfer-ownership="none">
            <doc xml:space="preserve">The module name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="resident" transfer-ownership="none">
            <doc xml:space="preserve">If the module should be resident.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_embedded"
                   c:identifier="peas_object_module_new_embedded"
                   version="1.18"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #PeasObjectModule for an embedded plugin.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #PeasObjectModule.</doc>
          <type name="ObjectModule" c:type="PeasObjectModule*"/>
        </return-value>
        <parameters>
          <parameter name="module_name" transfer-ownership="none">
            <doc xml:space="preserve">The module name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="symbol" transfer-ownership="none">
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </constructor>
      <constructor name="new_full"
                   c:identifier="peas_object_module_new_full"
                   introspectable="0">
        <doc xml:space="preserve">Creates a new #PeasObjectModule.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #PeasObjectModule.

Since 1.14</doc>
          <type name="ObjectModule" c:type="PeasObjectModule*"/>
        </return-value>
        <parameters>
          <parameter name="module_name" transfer-ownership="none">
            <doc xml:space="preserve">The module name.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="path" transfer-ownership="none">
            <doc xml:space="preserve">The path.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
          <parameter name="resident" transfer-ownership="none">
            <doc xml:space="preserve">If the module should be resident.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
          <parameter name="local_linkage" transfer-ownership="none">
            <doc xml:space="preserve">Whether to load the module with local linkage.</doc>
            <type name="gboolean" c:type="gboolean"/>
          </parameter>
        </parameters>
      </constructor>
      <method name="create_object"
              c:identifier="peas_object_module_create_object"
              introspectable="0">
        <doc xml:space="preserve">Creates an object for the @interface passing @n_parameters
and @parameters to the #PeasFactoryFunc. If @module does
not provide a #PeasFactoryFunc for @interface then
%NULL is returned.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">The created object, or %NULL.</doc>
          <type name="GObject.Object" c:type="GObject*"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the extension interface.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="n_parameters" transfer-ownership="none">
            <doc xml:space="preserve">The number of paramteters.</doc>
            <type name="guint" c:type="guint"/>
          </parameter>
          <parameter name="parameters" transfer-ownership="none">
            <doc xml:space="preserve">The parameters.</doc>
            <array length="1" zero-terminated="0" c:type="GParameter*">
              <type name="GObject.Parameter" c:type="GParameter"/>
            </array>
          </parameter>
        </parameters>
      </method>
      <method name="get_library"
              c:identifier="peas_object_module_get_library"
              introspectable="0">
        <doc xml:space="preserve">Gets the library.</doc>
        <return-value>
          <doc xml:space="preserve">the library.</doc>
          <type name="GModule.Module" c:type="GModule*"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module_name"
              c:identifier="peas_object_module_get_module_name"
              introspectable="0">
        <doc xml:space="preserve">Gets the module name.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the module name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_path"
              c:identifier="peas_object_module_get_path"
              introspectable="0">
        <doc xml:space="preserve">Gets the path.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the path.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_symbol"
              c:identifier="peas_object_module_get_symbol"
              version="1.18"
              introspectable="0">
        <doc xml:space="preserve">Gets the symbol name used to register extension implementations.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the symbol name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="provides_object"
              c:identifier="peas_object_module_provides_object"
              introspectable="0">
        <doc xml:space="preserve">Determines if the module provides an extension for @interface.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">if the module provides an extension for @interface.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
          <parameter name="interface" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the extension interface.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_extension_factory"
              c:identifier="peas_object_module_register_extension_factory">
        <doc xml:space="preserve">Register an implementation for an extension type through a factory
function @factory_func which will instantiate the extension when
requested.

This method is primarily meant to be used by native bindings (like gtkmm),
creating native types which cannot be instantiated correctly using
g_object_new().  For other uses, you will usually prefer relying on
peas_object_module_register_extension_type().</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">Your plugin's #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
          <parameter name="iface_type" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the extension interface you implement.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="factory_func"
                     transfer-ownership="none"
                     scope="notified"
                     closure="2"
                     destroy="3">
            <doc xml:space="preserve">The #PeasFactoryFunc that will create the @iface_type
  instance when requested.</doc>
            <type name="FactoryFunc" c:type="PeasFactoryFunc"/>
          </parameter>
          <parameter name="user_data"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">Data to pass to @func calls.</doc>
            <type name="gpointer" c:type="gpointer"/>
          </parameter>
          <parameter name="destroy_func"
                     transfer-ownership="none"
                     scope="async">
            <doc xml:space="preserve">A #GDestroyNotify for @user_data.</doc>
            <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
          </parameter>
        </parameters>
      </method>
      <method name="register_extension_type"
              c:identifier="peas_object_module_register_extension_type">
        <doc xml:space="preserve">Register an extension type which implements the extension interface
@iface_type.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="module" transfer-ownership="none">
            <doc xml:space="preserve">Your plugin's #PeasObjectModule.</doc>
            <type name="ObjectModule" c:type="PeasObjectModule*"/>
          </instance-parameter>
          <parameter name="iface_type" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of the extension interface you implement.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
          <parameter name="extension_type" transfer-ownership="none">
            <doc xml:space="preserve">The #GType of your implementation of @iface_type.</doc>
            <type name="GType" c:type="GType"/>
          </parameter>
        </parameters>
      </method>
      <property name="local-linkage"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <doc xml:space="preserve">This property indicates whether the module is loaded with
local linkage, i.e. #G_MODULE_BIND_LOCAL.

Since 1.14</doc>
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="module-name"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="path"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <property name="resident"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="gboolean" c:type="gboolean"/>
      </property>
      <property name="symbol"
                writable="1"
                construct-only="1"
                transfer-ownership="none">
        <type name="utf8" c:type="gchar*"/>
      </property>
      <field name="parent">
        <type name="GObject.TypeModule" c:type="GTypeModule"/>
      </field>
      <field name="priv">
        <type name="ObjectModulePrivate" c:type="PeasObjectModulePrivate*"/>
      </field>
    </class>
    <record name="ObjectModuleClass"
            c:type="PeasObjectModuleClass"
            glib:is-gtype-struct-for="ObjectModule">
      <doc xml:space="preserve">The class structure for #PeasObjectModule.</doc>
      <field name="parent_class">
        <doc xml:space="preserve">The parent class.</doc>
        <type name="GObject.TypeModuleClass" c:type="GTypeModuleClass"/>
      </field>
      <field name="padding" readable="0" private="1">
        <array zero-terminated="0" c:type="gpointer" fixed-size="8">
          <type name="gpointer" c:type="gpointer"/>
        </array>
      </field>
    </record>
    <record name="ObjectModulePrivate"
            c:type="PeasObjectModulePrivate"
            disguised="1">
    </record>
    <record name="PluginInfo"
            c:type="PeasPluginInfo"
            glib:type-name="PeasPluginInfo"
            glib:get-type="peas_plugin_info_get_type"
            c:symbol-prefix="plugin_info">
      <doc xml:space="preserve">The #PeasPluginInfo structure contains only private data and should only
be accessed using the provided API.</doc>
      <method name="get_authors" c:identifier="peas_plugin_info_get_authors">
        <doc xml:space="preserve">Gets a %NULL-terminated array of strings with the authors of the plugin.

The relevant key in the plugin info file is "Authors".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's author list.</doc>
          <array c:type="gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_copyright"
              c:identifier="peas_plugin_info_get_copyright">
        <doc xml:space="preserve">Gets the copyright of the plugin.

The relevant key in the plugin info file is "Copyright".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's copyright information.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_data_dir" c:identifier="peas_plugin_info_get_data_dir">
        <doc xml:space="preserve">Gets the data dir of the plugin.

The module data directory is the directory where a plugin should find its
runtime data. This is not a value read from the #GKeyFile, but rather a
value provided by the #PeasEngine, depending on where the plugin file was
found.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's data dir.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_dependencies"
              c:identifier="peas_plugin_info_get_dependencies">
        <doc xml:space="preserve">Gets the dependencies of the plugin.

The #PeasEngine will always ensure that the dependencies of a plugin are
loaded when the said plugin is loaded. It means that dependencies are
loaded before the plugin, and unloaded after it. Circular dependencies of
plugins lead to undefined loading order.

The relevant key in the plugin info file is "Depends".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's dependencies.</doc>
          <array c:type="const gchar**">
            <type name="utf8"/>
          </array>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_description"
              c:identifier="peas_plugin_info_get_description">
        <doc xml:space="preserve">Gets the description of the plugin.

The description of the plugin should be a string presenting the purpose of
the plugin. It will typically be presented in a plugin's about box.

The relevant key in the plugin info file is "Description".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's description.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_external_data"
              c:identifier="peas_plugin_info_get_external_data"
              version="1.6">
        <doc xml:space="preserve">Gets external data specified for the plugin.

External data is specified in the plugin info file prefixed with X-. For
example, if a key/value pair X-Peas=1 is specified in the key file, you
can use "Peas" for @key to retrieve the value "1".

Note: that you can omit the X- prefix when retrieving the value,
but not when specifying the value in the file.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the external data, or %NULL if the external data could not be found.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
          <parameter name="key" transfer-ownership="none">
            <doc xml:space="preserve">The key to lookup.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_help_uri" c:identifier="peas_plugin_info_get_help_uri">
        <doc xml:space="preserve">Gets the help URI of the plugin.

The Help URI of a plugin will typically be presented by the plugin manager
as a "Help" button linking to the URI. It can either be a HTTP URL on some
website or a ghelp: URI if a Gnome help page is available for the plugin.

The relevant key in the plugin info file is "Help". Other platform-specific
keys exist for platform-specific help files. Those are "Help-GNOME",
"Help-Windows" and "Help-MacOS-X".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's help URI.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_icon_name"
              c:identifier="peas_plugin_info_get_icon_name">
        <doc xml:space="preserve">Gets the icon name of the plugin.

The icon of the plugin will be presented in the plugin manager UI. If no
icon is specified, the default green puzzle icon will be used.

The relevant key in the plugin info file is "Icon".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's icon name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module_dir"
              c:identifier="peas_plugin_info_get_module_dir">
        <doc xml:space="preserve">Gets the module directory.

The module directory is the directory where the plugin file was found. This
is not a value from the #GKeyFile, but rather a value provided by the
#PeasEngine.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the module directory.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_module_name"
              c:identifier="peas_plugin_info_get_module_name">
        <doc xml:space="preserve">Gets the module name.

The module name will be used to find the actual plugin. The way this value
will be used depends on the loader (i.e. on the language) of the plugin.
This value is also used to uniquely identify a particular plugin.

The relevant key in the plugin info file is "Module".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the module name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_name" c:identifier="peas_plugin_info_get_name">
        <doc xml:space="preserve">Gets the name of the plugin.

The name of a plugin should be a nice short string to be presented in UIs.

The relevant key in the plugin info file is "Name".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's name.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_settings"
              c:identifier="peas_plugin_info_get_settings"
              version="1.4">
        <doc xml:space="preserve">Creates a new #GSettings for the given @schema_id and if
gschemas.compiled is not in the module directory an attempt
will be made to create it.</doc>
        <return-value transfer-ownership="full">
          <doc xml:space="preserve">a new #GSettings, or %NULL.</doc>
          <type name="Gio.Settings" c:type="GSettings*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
          <parameter name="schema_id"
                     transfer-ownership="none"
                     nullable="1"
                     allow-none="1">
            <doc xml:space="preserve">The schema id.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="get_version" c:identifier="peas_plugin_info_get_version">
        <doc xml:space="preserve">Gets the version of the plugin.

The relevant key in the plugin info file is "Version".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's version.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="get_website" c:identifier="peas_plugin_info_get_website">
        <doc xml:space="preserve">Gets the website of the plugin.

The relevant key in the plugin info file is "Website".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">the plugin's associated website.</doc>
          <type name="utf8" c:type="const gchar*"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="has_dependency"
              c:identifier="peas_plugin_info_has_dependency">
        <doc xml:space="preserve">Check if the plugin depends on another plugin.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">whether the plugin depends on the plugin @module_name.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
          <parameter name="module_name" transfer-ownership="none">
            <doc xml:space="preserve">The name of the plugin to check.</doc>
            <type name="utf8" c:type="const gchar*"/>
          </parameter>
        </parameters>
      </method>
      <method name="is_available"
              c:identifier="peas_plugin_info_is_available"
              throws="1">
        <doc xml:space="preserve">Check if the plugin is available.

A plugin is marked as not available when there is no loader available to
load it, or when there has been an error when trying to load it previously.
If not available then @error will be set.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the plugin is available.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_builtin" c:identifier="peas_plugin_info_is_builtin">
        <doc xml:space="preserve">Check if the plugin is a builtin plugin.

A builtin plugin is a plugin which cannot be enabled or disabled by the
user through a plugin manager (like #PeasGtkPluginManager). Loading or
unloading such plugins is the responsibility of the application alone.
Most applications will usually load those plugins immediately after
the initialization of the #PeasEngine.

The relevant key in the plugin info file is "Builtin".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the plugin is a builtin plugin, %FALSE
if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_hidden" c:identifier="peas_plugin_info_is_hidden">
        <doc xml:space="preserve">Check if the plugin is a hidden plugin.

A hidden plugin is a plugin which cannot be seen by a
user through a plugin manager (like #PeasGtkPluginManager). Loading and
unloading such plugins is the responsibility of the application alone or
through plugins that depend on them.

The relevant key in the plugin info file is "Hidden".</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the plugin is a hidden plugin, %FALSE
if not.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <method name="is_loaded" c:identifier="peas_plugin_info_is_loaded">
        <doc xml:space="preserve">Check if the plugin is loaded.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE if the plugin is loaded.</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="info" transfer-ownership="none">
            <doc xml:space="preserve">A #PeasPluginInfo.</doc>
            <type name="PluginInfo" c:type="const PeasPluginInfo*"/>
          </instance-parameter>
        </parameters>
      </method>
      <function name="error_quark" c:identifier="peas_plugin_info_error_quark">
        <return-value transfer-ownership="none">
          <type name="GLib.Quark" c:type="GQuark"/>
        </return-value>
      </function>
    </record>
    <enumeration name="PluginInfoError"
                 c:type="PeasPluginInfoError"
                 glib:error-domain="peas-plugin-info-error">
      <doc xml:space="preserve">These identify the various errors that can occur while
loading a plugin.</doc>
      <member name="loading_failed"
              value="0"
              c:identifier="PEAS_PLUGIN_INFO_ERROR_LOADING_FAILED">
        <doc xml:space="preserve">The plugin failed to load.</doc>
      </member>
      <member name="loader_not_found"
              value="1"
              c:identifier="PEAS_PLUGIN_INFO_ERROR_LOADER_NOT_FOUND">
        <doc xml:space="preserve">The plugin's loader was not found.</doc>
      </member>
      <member name="dep_not_found"
              value="2"
              c:identifier="PEAS_PLUGIN_INFO_ERROR_DEP_NOT_FOUND">
        <doc xml:space="preserve">A dependency of the plugin was not found.</doc>
      </member>
      <member name="dep_loading_failed"
              value="3"
              c:identifier="PEAS_PLUGIN_INFO_ERROR_DEP_LOADING_FAILED">
        <doc xml:space="preserve">A dependency of the plugin failed to load.</doc>
      </member>
    </enumeration>
    <function name="plugin_info_error_quark"
              c:identifier="peas_plugin_info_error_quark"
              moved-to="PluginInfo.error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
  </namespace>
</repository>
